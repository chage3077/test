# C++函数编程模块
## 函数的要求
* 提供函数的定义
* 提供函数的原型
* 调用函数
```cpp
#include<iostream>
using namespace std;
// 声明函数，函数的定义
void function(int num); // 1.函数的定义
int main()
{
    int b = 200;
    function(b); // 3.调用函数
}

// 2.提供函数的原型
void function(int num)
{
    cout << "test number: "<< num <<endl;
}
```
```cpp
// 函数的定义方法
typeName 函数名 （参数列表）
{
    函数体
    return value; // value的类型与typeName相同
}
```
## 函数的参数
### 参数传递值
传入函数的参数称为形参，函数外部的参数为实参。实参和形参只有复制关系，改变形参的值不会影响实参的值。

### 参数传递地址（指针）
* 传递数组
```cpp
const int Size = 8;
// 声明函数
int addArry(int arr[],int size); // 数组作为形参
int main()
{
    int arr[Size] = {1,2,3,4,5,6,7,8};
    int result = 0;
    // 调用函数
    result = addArry(arr,Size); // 本质上传递的是一个地址 arr表示&arr[0]首地址
}
// 定义函数
int addArry(int arr[],int size) 
{
    int temp = 0;
    for(int i = 0; i < size; i++)
    {
        temp += arr[i];
    }
    return temp; // 返回值
}
```
* 对于传递地址到函数里面，可以直接修改原始数据。只进行可读权限，可以在传递参数时使用const关键字防止内容被修改。
```cpp
int addArry(const int arr[],int size); // 此时在函数体内不能对arr数组内的元素修改
```
* 对于数组的一些函数操作，需要传递数组首地址和元素个数。我们也可以指定数组范围传递参数，利用头指针和尾指针记录数组的范围。
```cpp
int addArry(const int* hand,const int* end)
{
    int totol; // 用于记录总和
    int* pt; // 用于检测循环条件
    for(pt = hand; pt != end; pt++) // 类似链表的思想了
    {
        totol += *pt; // 获取pt指针所指处的值，累加
    }
    return total;
}
```
* 传递二维数组</br>
```cpp
// 定义一个二维数组
int data[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}} // 三行四列的数组
// 将二维数组定义成指针的形式
int (*pt)[4]; // 指向的数组有3个元素，每个元素由4个int类型组成
//ps:没有括号表达的意思是，指向4个int的指针组成的数组
int* pt[4]; // 存放四个指向int的地址

// 作为参数传递时
int sum(int (*pt)[4],int size); // size是二维数组的行数
int sun(int data[][4],int size);

// 在函数定义时使用二维数组的元素
int sum(int data[][4],int size)
{
    int totol = 0;
    for(int i = 0;i < size;i++) // i表示行
        for(int j = 0;j < 4;j++) // j表示列
            total += data[i][j];
            
    return total;
}
```
![alt text](image_source/point3.png)
* 传递c风格字符串</br>
```cpp
// 传递字符串参数一般是传递第一个字符的地址
// 统计某字符的数量
unsigned int c_in_str(const char *chars, char flag)
{
    unsigned int count = 0;
    for (int i = 0; chars[i] != '\0'; i++)
    {
        if (chars[i] == flag)
            count++;
    }

    return count;
}
void test24()
{
    const char *name = "LiLy Mary";
    const char *statement = "Hello,I want to buy a babi toy.Could you buy for me?";
    unsigned int num_L = c_in_str(name, 'L');      // 统计字符L的数量
    unsigned int num_u = c_in_str(statement, 'u'); // 统计字符u的数量

    cout << num_L << " L characters in " << name << endl;
    cout << num_u << " u characters in " << statement << endl;
}
```
## 函数的返回值
### 返回c风格类型的字符串
```cpp
// 在返回c风格字符串的数组时，可以返回其首地址
char* build_chars(char c,int n)
{
    char* temp = new char[n+1]; //考虑到空字符的存在
    temp[n]='\0'; // 将末尾设置空字符
    while(n>0)
    {
        temp[n-1]=c;
        n--;
    }
    return temp;
}
void test()
{
    int times = 20;
    char ch = 'z';
    char* ptr = build_chars(ch,times);
    cout << ptr;
    delete[] ptr; // 删除new出来的内存
}
```
## 函数与结构
### 值传递结构
这样做可以很好的保护好数据，在函数体内拷贝一份，适用于结构体体量较小的情况.形参和实参都有自己的空间。
```cpp

```
### 传递结构地址
传递结构的地址，节省内存开支。
```cpp

```

