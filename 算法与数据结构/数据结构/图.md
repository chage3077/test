# 9.1图
## 9.1.1图的定义
图是一种非线性数据结构，由顶点和边组成。
## 9.1.2图的表示
* 邻接矩阵
* 邻接表：邻接表只存储真实存在的边，比起邻接矩阵更节省空间，但是查找边的效率比邻接矩阵慢。
## 9.1.3图的基本操作——用邻接矩阵进行实现
![alt text](../source/图的邻接矩阵理解.png)
```cpp
// 定义无向图
class GraphAdjMat
{
    vector<int> m_vertices; // 顶点列表，元素代表“顶点值”，索引代表“顶点索引”
    vector<vector<int>> adjMat; // 邻接矩阵

public:
    // 初始化
    GraphAdjMat(const vector<int> &vertices,const vecctor<vector<int>> &edges)
    {
        // 添加顶点
        for(int val:vertices)
        {
            addVertex(val);
        }
        // 添加边
        // edges 元素代表顶点索引，即对应 vertices 元素索引
        // 获取一条条的边
        for(const vector<int> &edge:edges)
        {
            int u = edge[0] // 顶点u索引
            int v = edge[1] // 顶点v索引
            addEdge(u,v);
        }
    }
    // 获取顶点数量
    int size()
    {
        return m_vertices.size();
    }
    // 添加顶点
    void addVertex(int val)
    {
       // 添加顶点到顶点容器中
       m_vertices.push_back(val);
       // 初始化邻接矩阵
       if(adjMat.empty())
        {
            adjMat.push_back(vector<int>(1,0)); // 形成1*1的矩阵，初始化为0
        }
        else
        {
            // 已经有邻接矩阵了，进行扩展
            int n = adjMat.size(); // 获取现在邻接矩阵的大小
            adjMat.push_back(vector<int>(n,0)); // 添加新行，行的大小必须是定点数-1，不然后面添加列的时候会冲突，所以是先获取原先大小，再添加新行

            // 添加新的列
            for(auto& row:adjMat)
            {
                // 获取邻接矩阵的每一行,扩展一格，相当于添加新的一列
                row.push_back(0); // 填充成0
            }
        }
    }
    // 添加边
    // i,j对应vertices元素索引
    void addEdge(int i,int j)
    {
        // 索引越界与相等处理
        if (i < 0 || j < 0 || i >= size() || j >= size() || i == j) {
            throw out_of_range("顶点不存在");
        }
        // 无向图中邻接矩阵关于主对角线对称，即满足 (i, j) == (j, i)
        adjMat[i][j] =1;
        adjMat[j][i] =1;
    }
    // 删除点，参数为点的索引
    void removeVertex(int i)
    {
        if (index >= size()) {
            throw out_of_range("顶点不存在");
        }
        // 从顶点数组中移除
        if(!m_vertices.empty())
        {
            m_vertices.erase(m_vertices.begin()+i);

        }
        // 从邻接矩阵中删除行列
        // 先删除行
        adjMat.erase(adjMat.begin()+i);
        // 删除列
        for(const auto& row : adjMat)
        {
            row.erase(row.begin()+i);
        }
    }
    // 删除边 参数是两个顶点的索引
    void removeEdge(int i,int j)
    {
        // 索引越界与相等处理
        if (i < 0 || j < 0 || i >= size() || j >= size() || i == j) {
            throw out_of_range("顶点不存在");
        }
        // 删除边就是在邻接矩阵中将对应的元素由1变成0
        adjMat[i][j] = 0;
        adjMat[j][i] = 0;
    }
};
```
## 9.1.4图的基本操作——用邻接表进行实现
利用链表实现邻接表
```cpp
// 基于邻接表实现无向图
struct Vertex
{
    // .....
};
class GraphAdjList
{
public:
    // 用哈希表实现邻接表，key：顶点，value：该顶点的所有邻接顶点，确保图的顶点是唯一的
    unordered_map<Vertex*,vector<Vertex *>> adjList;

    // 构造
    GraphAdjList(const vector<vector<Vertex*>> &edges)
    {
        // 添加所有的边和顶点
        for(const auto& edge : edges)
        {
            addVertex(edge[0]);
            addVertex(edge[1]);
            addEdge(edge[0],edge[1]);
        }
    }
    // 添加点
    void addVertex(Vertex* vet )
    {
        if(adjList.count(vet))
            return;
        // 在哈希表中添加一个新链表
        adjList[vet] = vector<Vertex*>();
    }
    // 删除顶点
    void removeVertex(Vertex* vet)
    {
        if(!adjList.count(vet))
            throw invalid_argument("不存在顶点");
        // 在邻接表（哈希表）中删除对应的链表（vector)
        adjList.erase(vet);
        // 遍历其他顶点的链表，删除包含vet的边
        for(auto & adj:adjList)
        {
            remove(adj.second,vet);
        }
    }
    // 在链表(vector)中删除指定节点
    void remove(vector<Vertex>& vec,Vertex* vet)
    {
        for(auto& it:vec)
        {
            if(it == vet)
            {
                vec.erase(it);
                break;
            }
        }
    }
    // 添加边
    void addEdge(Vertex* vet1, Vertex* vet2)
    {
        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)
            throw invalid_argument("不存在顶点");
        // 添加边
        adjList[v1].push_back(v2);
        adjList[v2].push_back(v1);
    }
    // 删除边
    void removeEdge(Vertex* vet1, Vertex* vet2)
    {
        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)
            throw invalid_argument("不存在顶点");
        remove(adjList[vet1],vet2);
        remove(adjList[vet2],vet1);
    }
    
};
```