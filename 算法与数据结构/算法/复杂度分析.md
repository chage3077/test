# 2.复杂度分析
## 2.1算法效率评估分析
在使用算法解决问题时，需要考虑这个算法是不是“最快最省”的。需要对多种算法进行评估和分析。</br>
两种方法进行分析：实际测试和理论估计
### 2.1.1实际测试
利用计算机直接展开测试，观察算法之间的运行时间和内存占用情况。</br>
缺点：</br>
* 难以排除测试环境的干扰因素
* 展开完整测试非常耗费资源
### 2.1.2理论估计
利用复杂度分析法分析算法所需的时间和空间(时间复杂度和空间复杂度)与输入数据之间的大小关系。<b>随着输入数据大小的增加，算法执行所需时间和空间的增长趋势</b>

## 2.2迭代
重复的完成每一项步骤
* for循环：适合在预先知道迭代次数时使用
* while循环：只需要知道停止循环条件

## 2.3递归
通过调用自身来解决问题</br>
递归代码的“三要素”：</br>
* 终止条件：什么时候把“递”（程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。）操作转换成“归”（触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果）操作
* 递归调用：对应“递”操作，函数调用自身，将参数进行化简
* 返回结果：对应“归”操作，将当前递归层级的结果返回至上一层
### 2.3.1普通递归
利用递归计算1+2+3+...........+n
```cpp
int count(int n)
{
    // 终止条件
    if(0==n)
    {
        return 1;
    }
    // 递归调用
    int res = count(n-1); // n-1：分解参数
    // 返回结果
    return n + res; // 向上返回结果
}
```
### 2.3.2尾递归
尾递归比普通递归更省空间，在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当
```cpp
int tailCount(int n , int res)
{
    // 终止条件
    if(1==n)
        return res;

    return tailCount(n-1,res+n);
}
```
### 2.3.3递归树
递归树出现在处理“分治”问题（一个复杂的问题分成两个或更多的相同或相似的子问题）。例如求解斐波那契数列，求第n个数是什么。已知f(n)=f(n-1)+f(n-2)，f(1)=0,f(2)=1。
```cpp
// 可以使用递归进行求解，分别找到f(n-1)和f(n-2)的值
int fib(int n)
{
    //终止条件f(1)=0,f(2)=1
    if(n==1||n==2)
    {
        return n-1;
    }
    // 递归树调用，两个分支
    int res = fib(n-1)+fib(n-2);
    return res;
}
```
## 2.4递归与迭代的对比
<b>|迭代|递归
---|---|---|
实现方式|循环|函数调用自身
时间效率|效率高，无函数调用开销|每次函数调用会产生开销
内存使用|通常使用固定大小的内存空间|累积函数调用可能使用大量的栈帧空间
适用范围|简单循环任务|子问题分解，例如：树、图、分治、回溯等

## 2.5递归与迭代的联系
递归的函数满足“先入后出”的思想。最先调用的函数最后面返回结果时才清空该栈帧内存</br>
* 递：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。</br>
* 归：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</br>
每一步调用函数和每一步返回结果就是迭代。</br>
```cpp
// 用显示栈迭代模拟递归操作
#include<stack>
int forLoopRecur(int n)
{
    stack<int> stack; // 用显示的栈模拟递归函数放入到调用栈中
    int res = 0;
    // 递归调用
    for(int i = n; i>0;i--)
    {
        stack.push(i); // 入栈操作模拟“递”
    }
    // 返回结果
    while(!stack.empty())
    {
        // 出栈操作模拟“归”
        res += stack.top(); // res = 1+2+3...+n
        stack.pop(); // 出栈
    }
    return res;
}

```
## 2.6 时间复杂度
### 2.6.1时间复杂度分析统计
误区：统计算法的运行时间</br>
<b>正确的是统计算法运行时间随着数据量变大时的增长趋势</b>

* 例子:统计算法的运行时间趋势
```cpp
// 算法 A 的时间复杂度：常数阶
/*
    原因：随着n的变大，算法内部只是运行一次cout语句。
    与n的大小没有关系，所以时间复杂度称为常数阶。
*/
void algorithm_A(int n) {
    cout << 0 << endl;
}

// 算法 B 的时间复杂度：线性阶
/*
    原因：算法内部是根据n的大小进行for循环，运行时间是
    与n的大小有关。运行时间随着n的变化而变化，呈线性关
    系。所以时间复杂度称为线性阶。
*/
void algorithm_B(int n) {
    for (int i = 0; i < n; i++) {
        cout << 0 << endl;
    }
}
// 算法 C 的时间复杂度：常数阶
/*
    原因：算法内部也是进行for循环，但是for循环的运行时
    间和n的大小无关。for循环执行1000000次这个时间是固
    定的，所以时间复杂度仍然是常数阶。
*/
void algorithm_C(int n) {
    for (int i = 0; i < 1000000; i++) {
        cout << 0 << endl;
    }
}
```
### 2.6.2时间复杂度分析的特点
* 可以有效的评估算法效率
* 时间复杂度的堆算方法简单
* 存在一定的局限性，在某些情况下难以判断算法效率的高低
### 2.6.3计算时间复杂度
* 函数渐近上界</br>
时间复杂度的本质就是计算“操作数量T(n)”的渐近上界
```cpp
// 给定一个输入数大小为n的函数：
void algorithm(int n) {
    int a = 1;  // +1
    a = a + 1;  // +1
    a = a * 2;  // +1
    // 循环 n 次
    for (int i = 0; i < n; i++) { // +1（每轮都执行 i ++）
        cout << 0 << endl;    // +1
    }
}

/*
    设算法的操作数量是一个关于输入数据大小n的函数，记为T(n) :
    T(n)=3+2n
    T(n)是一次函数，说明该算法的时间复杂度是线性阶的

*/
```
![alt text](../source/渐近上界.png)
### 2.6.4如何计算时间复杂度O(f(n))
要计算时间复杂度，首先要确定渐近函数f(n)，步骤如下：
* 计算操作数量T(n)
1.忽略T(n)中的常数项</br>
2.省略所有系数：循环2n次、5n+1次等，都可以简化记为n次</br>
3.循环嵌套时使用乘法：总操作数量等于外层循环和内层循环操作数量之积</br>
```cpp
void algorithm(int n) {
    int a = 1;  // +0（技巧 1:+1被忽略，因为是常数项）
    a = a + n;  // +0（技巧 1:+1被忽略，因为是常数项）
    // +n（技巧 2：忽略系数5）
    for (int i = 0; i < 5 * n + 1; i++) {
        cout << 0 << endl;
    }
    // +n*n（技巧 3：嵌套循环进行乘积计算）
    for (int i = 0; i < 2 * n; i++) {
        for (int j = 0; j < n + 1; j++) {
            cout << 0 << endl;
        }
    }
    // 所以T(n)=n+n²
}
```
* 确定渐近上界</br>
渐近上界由T(n)最高阶确定的，这是因为在 
 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。
