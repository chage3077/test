# 复杂度分析
## 算法效率评估分析
在使用算法解决问题时，需要考虑这个算法是不是“最快最省”的。需要对多种算法进行评估和分析。</br>
两种方法进行分析：实际测试和理论估计
### 实际测试
利用计算机直接展开测试，观察算法之间的运行时间和内存占用情况。</br>
缺点：</br>
* 难以排除测试环境的干扰因素
* 展开完整测试非常耗费资源
### 理论估计
利用复杂度分析法分析算法所需的时间和空间(时间复杂度和空间复杂度)与输入数据之间的大小关系。<b>随着输入数据大小的增加，算法执行所需时间和空间的增长趋势</b>

## 迭代
重复的完成每一项步骤
* for循环：适合在预先知道迭代次数时使用
* while循环：只需要知道停止循环条件

## 递归
通过调用自身来解决问题</br>
递归代码的“三要素”：</br>
* 终止条件：什么时候把“递”（程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。）操作转换成“归”（触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果）操作
* 递归调用：对应“递”操作，函数调用自身，将参数进行化简
* 返回结果：对应“归”操作，将当前递归层级的结果返回至上一层
### 普通递归
利用递归计算1+2+3+...........+n
```cpp
int count(int n)
{
    // 终止条件
    if(0==n)
    {
        return 1;
    }
    // 递归调用
    int res = count(n-1); // n-1：分解参数
    // 返回结果
    return n + res; // 向上返回结果
}
```
### 尾递归
尾递归比普通递归更省空间，在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当
```cpp
int tailCount(int n , int res)
{
    // 终止条件
    if(1==n)
        return res;

    return tailCount(n-1,res+n);
}
```
### 递归树
递归树出现在处理“分治”问题（一个复杂的问题分成两个或更多的相同或相似的子问题）。例如求解斐波那契数列，求第n个数是什么。已知f(n)=f(n-1)+f(n-2)，f(1)=0,f(2)=1。
```cpp
// 可以使用递归进行求解，分别找到f(n-1)和f(n-2)的值
int fib(int n)
{
    //终止条件f(1)=0,f(2)=1
    if(n==1||n==2)
    {
        return n-1;
    }
    // 递归树调用，两个分支
    int res = fib(n-1)+fib(n-2);
    return res;
}
```
## 递归与迭代的对比
<b>|迭代|递归
---|---|---|
实现方式|循环|函数调用自身
时间效率|效率高，无函数调用开销|每次函数调用会产生开销
内存使用|通常使用固定大小的内存空间|累积函数调用可能使用大量的栈帧空间
适用范围|简单循环任务|子问题分解，例如：树、图、分治、回溯等

## 递归与迭代的联系
递归的函数满足“先入后出”的思想。最先调用的函数最后面返回结果时才清空该栈帧内存</br>
* 递：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。</br>
* 归：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</br>
每一步调用函数和每一步返回结果就是迭代。</br>
```cpp
// 用显示栈迭代模拟递归操作
#include<stack>
int forLoopRecur(int n)
{
    stack<int> stack; // 用显示的栈模拟递归函数放入到调用栈中
    int res = 0;
    // 递归调用
    for(int i = n; i>0;i--)
    {
        stack.push(i); // 入栈操作模拟“递”
    }
    // 返回结果
    while(!stack.empty())
    {
        // 出栈操作模拟“归”
        res += stack.top(); // res = 1+2+3...+n
        stack.pop(); // 出栈
    }
    return res;
}

```