# 简洁代码
## 1.auto类型推导
以前用于”自动存储期的局部变量“，现在用于<b>数据类型推导</b>
### 1.1 auto的使用方法
```cpp
int x = 0;
auto y = x; // y->int

const int a = 10;
auto b = a; // b->int
const auto c = a; // c->const int
```
由此可见，auto可以和cv限定符一起使用。
* 补充：cv限定符
```cpp
//1. const常量修饰符：值不能被修改
const int a = 10; // a在整个程序中不可更改
//2. volatile易变
// 告诉编译器该变量可能在任何时候被外部因素修改（例如硬件、操作系统或多个线程）。因此，编译器不能对该变量进行优化。
volatile int v 
```
### 1.2auto使用注意事项
auto推到数据类型
* auto不能用于函数参数
* auto不能用于模板参数类型
* auto不能定义数组
* auto不能定义非静态成员变量
### 1.3auto的使用场景
* 类型推导复杂的情况
```cpp
std::map<double,double>::iterator it = resultMap.begin();
for(;it!=resultMap.end();it++)
{
    // .....
}
// 定义迭代器非常繁琐，利用auto
auto it = resultMap.begin();
```
## 1.2 decltype
编译阶段推导表达式的类型，无需进行变量初始化
```cpp
int x = 0;
decltype(x) y = 1; // y->int
decltype(x+y) z = 0; // z->int
```
